# rr_fun_light_theme_final.py
# üåà Fun Light-Themed Round Robin Visual Game ‚Äî Cartoon & Educational Edition
# This file contains GUI + Animation + Round Robin CPU Scheduling logic
# All comments are simple and easy to understand.

import tkinter as tk
from tkinter import ttk, messagebox
import random, time
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# ------------------------------------------------------------
# ---------------------- THEME SETTINGS -----------------------
# ------------------------------------------------------------
# These colors and fonts make the GUI look attractive.

BG = "#e7f3ff"
CARD = "#ffffff"
ACCENT = "#0b2545"
HIGHLIGHT = "#0078d7"
FONT_HEADER = ("Comic Sans MS", 22, "bold")
FONT_SUB = ("Comic Sans MS", 13)
EMOJI_FONT = ("Segoe UI Emoji", 20)

# ------------------------------------------------------------
# --------------- EDUCATIONAL INFORMATION TEXT ----------------
# ------------------------------------------------------------
# These popups help the user understand the terms.

PARAM_INFO = {
    "Number of Processes": "How many processes are running.",
    "Burst Time": "How much CPU time each process needs.",
    "Arrival Time": "When the process comes into the system.",
    "Time Quantum": "Fixed time each process gets in one turn.",
    "Waiting Time": "Time spent waiting in the ready queue.",
    "Turnaround Time": "Total time from arrival to completion.",
    "Completion Time": "The time at which process finishes."
}

# Fun facts about Round Robin
FACTS = [
    "Round Robin gives each process equal CPU time!",
    "RR prevents starvation.",
    "Small quantum = too many context switches.",
    "RR is ideal for multitasking computers.",
    "Waiting Time and Turnaround Time show performance."
]

# Emojis for animation avatars
EMOJIS = ["üöó","üöÄ","üöÅ","üèéÔ∏è","üöú","üõµ","üõ∏","üê¢"]


# ------------------------------------------------------------
# ----------- ROUND ROBIN CPU SCHEDULING FUNCTION ------------
# ------------------------------------------------------------
# This function performs the actual Round Robin algorithm.
# It returns waiting time, turnaround time, completion time,
# and the Gantt chart data.

def simulate_rr(processes, burst, arrival, quantum, animate=None):
    n = len(processes)
    remaining = burst.copy()  # Remaining burst time
    time_now = 0              # Current time
    gantt = []                # Stores Gantt chart entries
    completion = [0]*n        # Completion times

    from collections import deque
    ready = deque()           # Ready queue for RR

    # Sort events by arrival time
    events = sorted([(arrival[i], i) for i in range(n)], key=lambda x:(x[0],x[1]))
    idx = 0

    # Load first processes that arrive at time 0
    if idx < n and events[idx][0] > time_now:
        time_now = events[idx][0]
    while idx < n and events[idx][0] <= time_now:
        ready.append(events[idx][1])
        idx += 1

    # Main RR loop
    while ready or idx < n:

        # If queue is empty, jump to next arrival
        if not ready:
            time_now = events[idx][0]
            while idx < n and events[idx][0] <= time_now:
                ready.append(events[idx][1])
                idx += 1
            continue

        # Pick first process in queue
        i = ready.popleft()
        start = time_now
        run = min(quantum, remaining[i])

        # Run animation for each time unit
        if animate:
            animate(processes[i], run)

        # Execute 1 time unit at a time
        for _ in range(run):
            time_now += 1
            remaining[i] -= 1

            # Add processes that arrive while running
            while idx < n and events[idx][0] <= time_now:
                ready.append(events[idx][1])
                idx += 1

        gantt.append((processes[i], start, time_now))

        # If unfinished, put back in queue
        if remaining[i] > 0:
            ready.append(i)
        else:
            completion[i] = time_now

    # Calculate turnaround and waiting time
    turnaround = [completion[i] - arrival[i] for i in range(n)]
    waiting = [turnaround[i] - burst[i] for i in range(n)]

    return {
        "gantt": gantt,
        "waiting": waiting,
        "turnaround": turnaround,
        "completion": completion,
        "avg_wt": sum(waiting)/n,
        "avg_tat": sum(turnaround)/n
    }


# ------------------------------------------------------------
# ----------------------- POPUP WINDOWS -----------------------
# ------------------------------------------------------------

# Shows meaning of a CPU scheduling parameter
def info_popup(title):
    txt = PARAM_INFO.get(title, "No info available.")
    win = tk.Toplevel()
    win.title(title)
    win.configure(bg=BG)

    tk.Label(win, text=title, font=("Comic Sans MS",16,"bold"),
             fg=HIGHLIGHT, bg=BG).pack(pady=10)

    tk.Message(win, text=txt, width=400, font=FONT_SUB,
               bg=CARD, fg=ACCENT).pack(padx=10,pady=10)

    tk.Button(win, text="Close", bg=HIGHLIGHT, fg="white",
              command=win.destroy).pack(pady=6)


# Fun fact popup
def facts_popup():
    w = tk.Toplevel()
    w.title("Round Robin Facts")
    w.configure(bg=BG)

    tk.Label(w, text="üí° Did You Know?",
             font=("Comic Sans MS",18,"bold"),
             fg=HIGHLIGHT, bg=BG).pack(pady=10)

    t = tk.Text(w, wrap="word", bg=CARD, fg=ACCENT, font=FONT_SUB)
    t.insert("1.0","\n\n".join(FACTS))
    t.config(state="disabled")
    t.pack(expand=True, fill="both", padx=12,pady=10)

    tk.Button(w, text="Close", bg=HIGHLIGHT, fg="white",
              command=w.destroy).pack(pady=6)


# ------------------------------------------------------------
# ------------------ MAIN APPLICATION CLASS ------------------
# ------------------------------------------------------------
# This class contains all screens:
# 1) Start screen
# 2) Input screen
# 3) Animation screen
# 4) Results screen

class RoundRobinApp:
    def __init__(self, root):
        self.root = root
        self.root.title("üéì Round Robin Visual Game ‚Äî Light Theme")
        self.root.geometry("1150x740")
        self.root.configure(bg=BG)

        self.frames = {}
        self.create_frames()
        self.show("start")

    # --------------------------------------------------------
    # Create all screens (frames)
    # --------------------------------------------------------
    def create_frames(self):

        # ------------------ START SCREEN ---------------------
        s = tk.Frame(self.root, bg=BG)

        tk.Label(s, text="üé® Round Robin ‚Äî Fun Learning Game",
                 font=FONT_HEADER, fg=HIGHLIGHT, bg=BG).pack(pady=20)

        tk.Label(s, text="Visualize CPU scheduling like a fun race!",
                 font=FONT_SUB, fg=ACCENT, bg=BG).pack(pady=6)

        tk.Button(s, text="Start ‚ñ∂", font=FONT_SUB,
                  bg=HIGHLIGHT, fg="white",
                  command=lambda:self.show("input")).pack(pady=20)

        tk.Button(s, text="Show Facts üí°", bg="#2ca02c",
                  fg="white", command=facts_popup).pack(pady=5)

        self.frames["start"] = s


        # ------------------ INPUT SCREEN ---------------------
        inp = tk.Frame(self.root, bg=BG)

        tk.Label(inp, text="Set Your Simulation Parameters",
                 font=("Comic Sans MS",18,"bold"),
                 fg=HIGHLIGHT, bg=BG).pack(pady=10)

        grid = tk.Frame(inp, bg=BG)
        grid.pack(pady=8)

        labels = [
            ("Number of Processes","3"),
            ("Burst Time","10 5 8"),
            ("Arrival Time","0 1 2"),
            ("Time Quantum","2")
        ]

        self.inputs = []

        # Create input boxes
        for i,(lbl,default) in enumerate(labels):
            tk.Label(grid, text=lbl, font=FONT_SUB, fg=ACCENT,
                     bg=BG).grid(row=i,column=0,sticky="w",padx=5,pady=6)

            tk.Button(grid,text="‚ÑπÔ∏è",bg=CARD,
                      command=lambda l=lbl:info_popup(l)).grid(row=i,column=1)

            e=tk.Entry(grid,font=FONT_SUB,width=30,bg=CARD,fg=ACCENT)
            e.insert(0,default)
            e.grid(row=i,column=2,padx=10,pady=6)
            self.inputs.append(e)

        tk.Button(inp, text="Run Simulation ‚ñ∂", bg=HIGHLIGHT,
                  fg="white", font=FONT_SUB,
                  command=self.start_sim).pack(pady=16)

        tk.Button(inp, text="Back", bg="#aaa", fg="black",
                  command=lambda:self.show("start")).pack(pady=5)

        self.frames["input"]=inp


        # ---------------- ANIMATION SCREEN -------------------
        anim=tk.Frame(self.root,bg=BG)

        tk.Label(anim,text="üèÅ CPU Race ‚Äî Processes take turns!",
                 font=("Comic Sans MS",18,"bold"),
                 fg=HIGHLIGHT,bg=BG).pack(pady=8)

        # Canvas for animation
        self.canvas=tk.Canvas(anim,width=1000,height=400,
                              bg="#f9fcff",highlightthickness=0)
        self.canvas.pack(pady=10)

        self.time_label=tk.Label(anim,text="Time: 0",font=FONT_SUB,
                                 fg=ACCENT,bg=BG)
        self.time_label.pack()

        tk.Button(anim,text="Show Results ‚ûú",bg=HIGHLIGHT,fg="white",
                  command=lambda:self.show("results")).pack(pady=10)

        self.frames["animation"]=anim


        # ------------------- RESULTS SCREEN ------------------
        res=tk.Frame(self.root,bg=BG)

        tk.Label(res,text="Results",
                 font=("Comic Sans MS",18,"bold"),
                 fg=HIGHLIGHT,bg=BG).pack(pady=8)

        # Table headings
        cols=("Process","Burst","Arrival","Waiting","Turnaround","Completion")
        self.table=ttk.Treeview(res,columns=cols,show="headings",height=8)

        for c in cols:
            self.table.heading(c,text=c)
            self.table.column(c,width=130,anchor="center")

        self.table.pack(pady=10)

        self.avg_label=tk.Label(res,text="",font=FONT_SUB,fg=ACCENT,bg=BG)
        self.avg_label.pack(pady=5)

        # Info buttons
        expl_frame=tk.Frame(res,bg=BG)
        expl_frame.pack(pady=6)

        for name in ["Arrival Time","Burst Time","Waiting Time",
                     "Turnaround Time","Completion Time"]:
            tk.Button(expl_frame,text=name,bg="#b3d9ff",fg=ACCENT,
                      command=lambda n=name:info_popup(n)).pack(side="left",padx=4)

        # Gantt Chart space
        self.chart_frame=tk.Frame(res,bg=BG)
        self.chart_frame.pack(pady=8)

        tk.Button(res,text="Play Again üîÅ",bg=HIGHLIGHT,fg="white",
                  command=lambda:self.show("input")).pack(pady=10)

        tk.Button(res,text="Back to Home",bg="#aaa",fg="black",
                  command=lambda:self.show("start")).pack()

        self.frames["results"]=res


    # --------------------------------------------------------
    # Function to switch between screens
    # --------------------------------------------------------
    def show(self,name):
        for f in self.frames.values():
            f.pack_forget()
        self.frames[name].pack(fill="both",expand=True)


    # --------------------------------------------------------
    # Handle Start Simulation Button Click
    # --------------------------------------------------------
    def start_sim(self):
        try:
            n=int(self.inputs[0].get().strip())
            burst=list(map(int,self.inputs[1].get().strip().split()))
            arrival=list(map(int,self.inputs[2].get().strip().split()))
            q=int(self.inputs[3].get().strip())

            # Basic input validation
            if not (len(burst)==len(arrival)==n):
                messagebox.showerror("Error","Burst & Arrival counts must match number of processes.")
                return

            self.processes=[f"P{i+1}" for i in range(n)]
            self.burst=burst
            self.arrival=arrival
            self.quantum=q

            self.show("animation")
            self.root.update()

            self.run_animation()

        except Exception as e:
            messagebox.showerror("Error",str(e))


    # --------------------------------------------------------
    # Main Function That Runs Animation + Calls RR Algorithm
    # --------------------------------------------------------
    def run_animation(self):
        c=self.canvas
        c.delete("all")

        n=len(self.processes)
        top=40
        track_h=60

        bars={}
        avatars={}

        # Draw lanes and avatars
        for i,p in enumerate(self.processes):
            y=top+i*track_h

            c.create_rectangle(60,y-8,920,y+28,
                               fill="#eaf6ff",outline="#cce0ff")

            c.create_text(25,y+8,text=EMOJIS[i%len(EMOJIS)],
                          font=EMOJI_FONT)

            c.create_text(45,y+8,text=p,font=("Comic Sans MS",11,"bold"),
                          fill=ACCENT,anchor="w")

            bar=c.create_rectangle(60,y,60,y+20,
                                   fill=random.choice(["#66b3ff","#ff9999","#99ff99","#ffd480"]),
                                   outline="")

            bars[p]=bar
            avatars[p]=c.create_text(70,y+10,text=EMOJIS[i%len(EMOJIS)],
                                     font=("Segoe UI Emoji",16))

        pixels=15
        tick=0.1
        self.time=0

        # Animation for each running time unit
        def animate(proc,dur):
            for _ in range(dur):
                c.move(bars[proc],pixels,0)
                c.move(avatars[proc],pixels,0)
                self.time+=1
                self.time_label.config(text=f"Time: {self.time}")
                c.update()
                time.sleep(tick)

        # Call scheduling function
        res=simulate_rr(self.processes,self.burst,self.arrival,self.quantum,animate)
        self.result=res

        self.show("results")
        self.show_results()


    # --------------------------------------------------------
    # Show Results Table + Gantt Chart
    # --------------------------------------------------------
    def show_results(self):
        res=self.result

        # Clear table
        for i in self.table.get_children():
            self.table.delete(i)

        # Insert new rows
        for i,p in enumerate(self.processes):
            self.table.insert("", "end",
                values=(p,self.burst[i],self.arrival[i],
                        res["waiting"][i],res["turnaround"][i],
                        res["completion"][i]))

        self.avg_label.config(text=f"Average Waiting: {res['avg_wt']:.2f} | Average Turnaround: {res['avg_tat']:.2f}")

        # Clear old Gantt chart
        for w in self.chart_frame.winfo_children():
            w.destroy()

        # Draw new chart
        fig,ax=plt.subplots(figsize=(9,2.5))
        colors=["#66b3ff","#ff9999","#99ff99","#ffd480","#c2c2f0","#ffb3e6"]

        cmap={}

        for proc,s,e in res["gantt"]:
            if proc not in cmap:
                cmap[proc]=random.choice(colors)

            ax.barh(0,e-s,left=s,color=cmap[proc],
                    edgecolor="white",height=0.5)

            ax.text((s+e)/2,0,proc,ha="center",va="center",fontsize=10)

        ax.set_yticks([])
        ax.set_xlabel("Time Units",fontsize=11)
        ax.set_title("Gantt Chart",fontsize=12,pad=10)

        for spine in ax.spines.values():
            spine.set_visible(False)

        ax.set_facecolor("#f9fcff")
        fig.patch.set_facecolor(BG)

        plt.tight_layout()

        canvas=FigureCanvasTkAgg(fig,master=self.chart_frame)
        canvas.draw()
        canvas.get_tk_widget().pack()



# ------------------------------------------------------------
# ------------------------- RUN APP --------------------------
# ------------------------------------------------------------
if __name__=="__main__":
    root=tk.Tk()
    app=RoundRobinApp(root)
    root.mainloop()
